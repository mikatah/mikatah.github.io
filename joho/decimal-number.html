<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>10進数の数え方アニメーション</title>
<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root {
    --transition-speed: 0.8s; /* JSで書き換えます */
  }

  body {
    font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", sans-serif;
    text-align: center;
    margin: 0;
    padding: 10px;
    background-color: #e0f7fa;
    color: #333;
    overflow-x: auto; /* 【変更】横スクロールを許可 */
  }

  h1 { margin: 10px 0 15px; font-size: 22px; color: #006064; }
  
  /* コントロール全体 */
  .controls-wrapper {
    background: white;
    border-radius: 15px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    display: inline-block;
    padding: 15px;
    margin-bottom: 15px;
    max-width: 95%;
  }

  /* 速度切り替えスイッチ */
  .speed-switch {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
    font-size: 14px;
    font-weight: bold;
    color: #555;
  }
  .speed-label {
    cursor: pointer;
    padding: 5px 15px;
    background: #eee;
    border-radius: 20px;
    transition: all 0.2s;
  }
  input[type="radio"] { display: none; }
  input[type="radio"]:checked + .speed-label {
    background: #00BCD4;
    color: white;
    box-shadow: 0 2px 5px rgba(0,188,212,0.4);
  }

  /* 入力とボタンの行 */
  .main-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    flex-wrap: wrap;
  }
  
  input[type="number"] { 
    padding: 10px; 
    font-size: 22px; 
    width: 80px; 
    border: 2px solid #ddd; 
    border-radius: 8px; 
    text-align: right;
    outline: none;
    font-weight: bold;
    color: #333;
  }
  input:focus { border-color: #00BCD4; }
  
  /* 共通ボタンスタイル */
  button {
    padding: 10px 20px;
    font-size: 16px;
    font-weight: bold;
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.2s;
    min-width: 120px;
    touch-action: manipulation;
  }
  button:active { transform: translateY(2px); box-shadow: none !important; }
  button:disabled { background-color: #ddd !important; box-shadow: none !important; cursor: not-allowed; transform: none !important; color: #aaa; }

  /* 進むボタン */
  #nextBtn {
    background-color: #00BCD4;
    box-shadow: 0 4px 0 #0097a7;
  }
  #nextBtn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 0 #0097a7; }
  
  #nextBtn.next-action {
    background-color: #FF9800;
    box-shadow: 0 4px 0 #F57C00;
    animation: pulse 1.5s infinite;
  }
  #nextBtn.next-action:hover { box-shadow: 0 6px 0 #F57C00; }

  /* 戻るボタン */
  #backBtn {
    background-color: #78909C;
    box-shadow: 0 4px 0 #546E7A;
  }
  #backBtn:hover:not(:disabled) { transform: translateY(-2px); background-color: #90A4AE; box-shadow: 0 6px 0 #546E7A; }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  /* ステージ */
  #stage {
    position: relative;
    width: 100%;
    max-width: 960px; /* 【変更】幅を広げる（赤枠約290px × 3 + α） */
    min-width: 920px; /* 【変更】最小幅を確保して赤枠がはみ出さないようにする */
    height: 500px; /* 【変更】高さを400pxから500pxへ拡大 */
    margin: 0 auto;
    background-color: white;
    border: 4px solid #4DD0E1;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
  }

  @media (max-width: 600px) {
    #stage { height: 550px; } /* 【変更】スマホ時はさらに少し高く */
    .main-controls { gap: 10px; }
    button { min-width: 100px; padding: 10px 15px; font-size: 14px; }
  }

  /* エリアラベル */
  .zone-label {
    position: absolute;
    bottom: 0;
    height: 30px;
    line-height: 30px;
    font-weight: bold;
    font-size: 14px;
    width: 33.33%;
    text-align: center;
    color: white;
  }
  #label-100 { left: 0; background-color: #ef5350; }
  #label-10 { left: 33.33%; background-color: #42A5F5; }
  #label-1 { left: 66.66%; background-color: #FFCA28; color: #5d4037; }

  .divider {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 2px;
    background-color: #eee;
    border-left: 2px dashed #ccc;
    z-index: 0;
  }

  /* ドット（1の位） */
  .dot {
    width: 14px;
    height: 14px;
    background-color: #FFE082; /* 薄い黄色 */
    border-radius: 50%;
    position: absolute;
    transition-property: left, top, transform, background-color, border-color;
    transition-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1);
    box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    z-index: 10;
    border: 1px solid #C8A415;
  }

  /* 10の棒（枠） */
  .group-box-10 {
    position: absolute;
    border: 2px solid #1E88E5;
    background-color: white;
    border-radius: 6px;
    transition-property: all;
    transition-timing-function: ease;
    opacity: 0;
    z-index: 5;
    pointer-events: none;
  }

  /* 100の板（枠） */
  .group-box-100 {
    position: absolute;
    border: 3px solid #e53935;
    background-color: white; /* 背景を白にして下の重なりを隠す */
    border-radius: 8px;
    transition: opacity 0.5s;
    opacity: 0;
    z-index: 4;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }
  .group-box-100::after {
    content: "100";
    color: #e53935;
    font-weight: bold;
    font-size: 24px;
    opacity: 0.2;
  }

  #result {
    margin-top: 10px;
    font-size: 18px;
    font-weight: bold;
    min-height: 1.5em;
    color: #333;
    padding: 0 10px;
  }
  
  .highlight-text {
    color: #e53935;
    font-size: 1.2em;
  }
</style>
</head>
<body>

<h1>10進数の数え方アニメーション</h1>

<div class="controls-wrapper">
  <!-- 速度調整 -->
  <div class="speed-switch">
    <label>
      <input type="radio" name="speed" value="normal" checked>
      <span class="speed-label">ふつう</span>
    </label>
    <label>
      <input type="radio" name="speed" value="slow">
      <span class="speed-label">ゆっくり</span>
    </label>
  </div>

  <!-- メイン操作 -->
  <div class="main-controls">
    <button id="backBtn" disabled>◀ もどる</button>
    
    <div>
      <span style="font-size:12px; color:#666; display:block; margin-bottom:2px;">かず (最大300)</span>
      <input type="number" id="numInput" min="1" max="300" value="123">
    </div>

    <button id="nextBtn">スタート ▶</button>
  </div>
</div>

<div id="result">かずを決めたらスタートを押してね！</div>

<div id="stage">
  <div class="divider" style="left: 33.33%;"></div>
  <div class="divider" style="left: 66.66%;"></div>
  
  <div id="label-100" class="zone-label">100のくらい</div>
  <div id="label-10" class="zone-label">10のくらい</div>
  <div id="label-1" class="zone-label">1のくらい</div>
</div>

<script>
// --- 定数・設定 ---
const DOT_SIZE = 14;
const GAP = 4;
// 10のまとまりの枠サイズ
const PADDING_X = 6;
const PADDING_Y = 6;
const BOX_WIDTH = DOT_SIZE + PADDING_X * 2;
const BOX_HEIGHT = (DOT_SIZE + GAP) * 9 + DOT_SIZE + PADDING_Y * 2;

// DOM要素
const nextBtn = document.getElementById('nextBtn');
const backBtn = document.getElementById('backBtn');
const input = document.getElementById('numInput');
const result = document.getElementById('result');
const stage = document.getElementById('stage');
const speedRadios = document.getElementsByName('speed');

// --- 状態管理 ---
let currentStep = 0; // 0:初期, 1:バラバラ, 2:10の位, 3:100の位
let totalNumber = 0;
let isAnimating = false;
let speedMultiplier = 1.0;

// --- イベントリスナー ---
nextBtn.addEventListener('click', handleNext);
backBtn.addEventListener('click', handleBack);
speedRadios.forEach(r => r.addEventListener('change', updateSpeed));

// 初期化
updateSpeed();

// --- 速度制御 ---
function updateSpeed() {
  const mode = document.querySelector('input[name="speed"]:checked').value;
  if (mode === 'slow') {
    speedMultiplier = 2.0;
    document.documentElement.style.setProperty('--transition-speed', '1.6s');
  } else {
    speedMultiplier = 1.0;
    document.documentElement.style.setProperty('--transition-speed', '0.8s');
  }
  // 既存の要素にも反映
  document.querySelectorAll('.dot, .group-box-10').forEach(el => {
    el.style.transitionDuration = getComputedStyle(document.documentElement).getPropertyValue('--transition-speed');
  });
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms * speedMultiplier));

// --- メインロジック ---

async function handleNext() {
  if (isAnimating) return;
  
  // スタート時
  if (currentStep === 0) {
    totalNumber = parseInt(input.value);
    if (isNaN(totalNumber) || totalNumber <= 0) {
      result.textContent = '1以上の数字を入れてね！';
      return;
    }
    if (totalNumber > 300) {
      totalNumber = 300;
      input.value = 300;
      result.textContent = '多いので300個にします！';
    }
    input.disabled = true; // 入力ロック
  }

  isAnimating = true;
  updateUIState();

  if (currentStep === 0) {
    await animateStep0to1();
    currentStep = 1;
  } else if (currentStep === 1) {
    await animateStep1to2();
    currentStep = 2;
  } else if (currentStep === 2) {
    await animateStep2to3();
    currentStep = 3;
  } else if (currentStep === 3) {
    // リセットして最初から
    resetToStep0();
    input.disabled = false;
    currentStep = 0;
  }

  isAnimating = false;
  updateUIState();
}

function handleBack() {
  if (isAnimating) return;
  if (currentStep <= 0) return;

  // 入力ロック解除はステップ0に戻った時だけ
  if (currentStep === 1) {
    resetToStep0();
    input.disabled = false;
    currentStep = 0;
  } else if (currentStep === 2) {
    // 1に戻る（アニメーションなしで即時描画）
    renderState1();
    currentStep = 1;
  } else if (currentStep === 3) {
    // 2に戻る（アニメーションなしで即時描画）
    renderState2();
    currentStep = 2;
  }
  
  result.textContent = "ひとつ もどったよ。";
  updateUIState();
}

// UIボタンの表示更新
function updateUIState() {
  const speed = getComputedStyle(document.documentElement).getPropertyValue('--transition-speed');
  
  // アニメーション中はボタン無効
  if (isAnimating) {
    nextBtn.disabled = true;
    backBtn.disabled = true;
    nextBtn.textContent = 'うごいています...';
    nextBtn.classList.remove('next-action');
    return;
  }

  // ステップに応じたボタン制御
  backBtn.disabled = (currentStep === 0);
  
  if (currentStep === 0) {
    nextBtn.disabled = false;
    nextBtn.textContent = 'スタート ▶';
    nextBtn.classList.remove('next-action');
    result.textContent = 'かずを決めたらスタートを押してね！';
  } else if (currentStep === 3) {
    nextBtn.disabled = false;
    nextBtn.textContent = 'もういちど ▶';
    nextBtn.classList.add('next-action');
  } else {
    nextBtn.disabled = false;
    nextBtn.textContent = 'つぎへすすむ ▶';
    nextBtn.classList.add('next-action');
  }
  
  // 要素のtransition時間を再適用（生成された要素向け）
  document.querySelectorAll('.dot, .group-box-10').forEach(el => {
    el.style.transitionDuration = speed;
  });
}

// --- ステップごとのアニメーション・描画関数 ---

// ステップ0: 初期化
function resetToStep0() {
  stage.querySelectorAll('.dot, .group-box-10, .group-box-100').forEach(el => el.remove());
  result.textContent = 'かずを決めたらスタートを押してね！';
}

// アニメーション: 0 -> 1 (ドット出現)
async function animateStep0to1() {
  result.textContent = 'ドットをならべています...';
  const dots = createDots(totalNumber);
  
  // 初期位置：ランダム（1の位エリア）
  placeDotsRandomly(dots);
  
  // 出現エフェクト
  for(let i=0; i<dots.length; i++) {
    dots[i].style.transform = 'scale(1)';
    if (i % 10 === 0) await sleep(10);
  }
  
  result.innerHTML = `<strong>${totalNumber}</strong> 個のドットがあるよ。<br>10個あつまったら変身するよ！`;
}

// 状態描画: 1 (バラバラ) - 戻るボタン用
function renderState1() {
  resetToStep0();
  const dots = createDots(totalNumber);
  placeDotsRandomly(dots);
  dots.forEach(d => d.style.transform = 'scale(1)');
  result.innerHTML = `<strong>${totalNumber}</strong> 個のドットがあるよ。`;
}

// アニメーション: 1 -> 2 (10のまとまり)
async function animateStep1to2() {
  const dots = Array.from(document.querySelectorAll('.dot'));
  const totalTens = Math.floor(totalNumber / 10);
  const layout = calculateLayout10();

  if (totalTens === 0) {
    result.textContent = "10個のかたまりは作れなかったね。";
    await sleep(500);
    return;
  }

  result.textContent = "10個ずつ あつまれ〜！";

  // 10個ずつ移動
  for (let t = 0; t < totalTens; t++) {
    const groupDots = [];
    const pos = getPos10(t, layout);

    for (let i = 0; i < 10; i++) {
      const dot = dots[t * 10 + i];
      groupDots.push(dot);
      
      const dotX = pos.x + PADDING_X; 
      const dotY = pos.y + PADDING_Y + i * (DOT_SIZE + GAP);
      
      dot.style.left = dotX + 'px';
      dot.style.top = dotY + 'px';
      // レイヤー順：枠より上にする
      dot.style.zIndex = 100 + t * 2 + 1;
      
      if (i === 0) await sleep(30);
    }
    
    await sleep(200);

    // 枠作成 (10の枠もz-indexを持たせる)
    const box = createBox10(pos.x, pos.y);
    // 重なりが出た時、後から作ったものが上に来るようにする
    box.style.zIndex = 100 + t * 2;
    
    await sleep(100);
  }

  // 余りの整列
  arrangeLooseDots(dots, totalTens * 10);
  
  result.innerHTML = `10個のかたまり： <span class="highlight-text">${totalTens}</span> 個`;
}

// 状態描画: 2 (10のまとまり) - 戻るボタン用
function renderState2() {
  resetToStep0();
  const dots = createDots(totalNumber);
  dots.forEach(d => d.style.transform = 'scale(1)'); // 即表示

  const totalTens = Math.floor(totalNumber / 10);
  const layout = calculateLayout10();

  // 10のまとまり配置（即時）
  for (let t = 0; t < totalTens; t++) {
    const pos = getPos10(t, layout);
    const box = createBox10(pos.x, pos.y, true); // true = 即時表示
    // レイヤー順設定
    box.style.zIndex = 100 + t * 2;

    for (let i = 0; i < 10; i++) {
      const dot = dots[t * 10 + i];
      const dotX = pos.x + PADDING_X; 
      const dotY = pos.y + PADDING_Y + i * (DOT_SIZE + GAP);
      
      // アニメーション無効化して配置
      dot.style.transition = 'none';
      dot.style.left = dotX + 'px';
      dot.style.top = dotY + 'px';
      dot.style.zIndex = 100 + t * 2 + 1; // 枠より1つ上
      
      // transition戻す
      setTimeout(() => dot.style.transition = '', 50);
    }
  }

  // 余りの整列（即時）
  arrangeLooseDots(dots, totalTens * 10, true);
  
  result.innerHTML = `10個のかたまり： <span class="highlight-text">${totalTens}</span> 個`;
}

// アニメーション: 2 -> 3 (100のまとまり)
async function animateStep2to3() {
  const totalTens = Math.floor(totalNumber / 10);
  const boxes10 = Array.from(document.querySelectorAll('.group-box-10'));
  const dots = Array.from(document.querySelectorAll('.dot'));
  
  let hundredsCount = 0;
  
  // 100の配置計算用
  const GROUP_SPACING = BOX_WIDTH + 2;
  const zone100StartX = stage.clientWidth * 0.02;
  const startY = 40;

  if (totalTens < 10) {
    result.innerHTML = `10個のかたまりが ${totalTens}個 だね。<br>10個ないから100にはなれないね。`;
    await sleep(500);
  } else {
    // 100作成ループ
    let processedTens = 0;
    while ((totalTens - processedTens) >= 10) {
      result.innerHTML = `10個のかたまりが10個あるから、<br><span style="color:#e53935">100の部屋</span>へ移動するよ！`;
      await sleep(800);

      const targetBigX = zone100StartX;
      const targetBigY = startY + hundredsCount * 20;

      // 移動用の一時的な高いZ-index
      const movingZIndexBase = 1000;

      // 10本の棒を移動
      for (let i = 0; i < 10; i++) {
        const boxIndex = processedTens + i;
        const box = boxes10[boxIndex];
        
        // 100枠内での位置
        const offsetX = 5 + i * GROUP_SPACING;
        const targetGroupX = targetBigX + offsetX;
        const targetGroupY = targetBigY + 5;

        // 枠移動
        box.style.left = targetGroupX + 'px';
        box.style.top = targetGroupY + 'px';
        // 移動中は最前面に
        box.style.zIndex = movingZIndexBase + i * 2; 

        // ドット移動
        for(let d=0; d<10; d++) {
            const dot = dots[boxIndex * 10 + d];
            dot.style.left = (targetGroupX + PADDING_X) + 'px';
            dot.style.top = (targetGroupY + PADDING_Y + d * (DOT_SIZE + GAP)) + 'px';
            // 移動中は最前面（枠より1つ上）
            dot.style.zIndex = movingZIndexBase + i * 2 + 1;
        }
        await sleep(50);
      }

      // 100枠作成
      const bigBoxWidth = GROUP_SPACING * 10 + 6;
      const bigBoxHeight = BOX_HEIGHT + 10;
      
      const bigBox = document.createElement('div');
      bigBox.className = 'group-box-100';
      bigBox.style.left = targetBigX + 'px';
      bigBox.style.top = targetBigY + 'px';
      bigBox.style.width = bigBoxWidth + 'px';
      bigBox.style.height = bigBoxHeight + 'px';
      
      // 【重要】階層構造の確定
      // 下から順に積み上げる
      // 1つ目の100セット (hundredsCount=0): Base 200
      // 2つ目の100セット (hundredsCount=1): Base 400 ... 上に乗る
      const baseLayerZ = 200 + hundredsCount * 200;
      
      // 1. 100の枠 (一番下)
      bigBox.style.zIndex = baseLayerZ; 

      stage.appendChild(bigBox);
      requestAnimationFrame(() => { bigBox.style.opacity = 1; });

      // 2. 10の枠とドットのZ-indexを、100の枠の上に再設定
      for (let i = 0; i < 10; i++) {
        const boxIndex = processedTens + i;
        
        // 10の枠: 100の枠より上 (Base + 10 + i*2)
        // ※ i*2 をするのは10枠同士の微細な前後関係を一応保つため
        const boxZ = baseLayerZ + 10 + i * 2;
        boxes10[boxIndex].style.zIndex = boxZ;
        
        for(let d=0; d<10; d++) {
            const dot = dots[boxIndex * 10 + d];
            // ドット: 自分の属する10の枠より上
            dot.style.zIndex = boxZ + 1;
        }
      }

      processedTens += 10;
      hundredsCount++;
      
      result.innerHTML = `10個のかたまりの10個のかたまり： <span class="highlight-text">${hundredsCount}</span> 個`;
      await sleep(800);
    }
    
    // 残りの10を整列
    if (processedTens < totalTens) {
      const layout = calculateLayout10();
      
      for(let i = processedTens; i < totalTens; i++) {
          const remainIdx = i - processedTens;
          const pos = getPos10(remainIdx, layout);
          const box = boxes10[i];
          
          box.style.left = pos.x + 'px';
          box.style.top = pos.y + 'px';
          
          // 残った10の枠は最前面のレイヤーグループに置く必要はないが、
          // 整理整頓として手前に表示しておく
          const remainZ = 1000 + i * 2;
          box.style.zIndex = remainZ;

          for(let d=0; d<10; d++) {
             const dot = dots[i * 10 + d];
             dot.style.left = (pos.x + PADDING_X) + 'px';
             dot.style.top = (pos.y + PADDING_Y + d * (DOT_SIZE + GAP)) + 'px';
             dot.style.zIndex = remainZ + 1;
          }
          await sleep(50);
      }
    }
  }

  // 最終結果表示
  const finalOnes = totalNumber % 10;
  const finalTens = Math.floor((totalNumber % 100) / 10);
  
  result.innerHTML = `
    <span style="color:#e53935; font-size:1.1em;">10個のかたまりの10個のかたまり： ${hundredsCount}個</span><br>
    <span style="color:#1E88E5; font-size:1.1em;">10個のかたまり： ${finalTens}個</span><br>
    <span style="color:#FBC02D; font-size:1.1em; text-shadow:1px 1px 0 #eee;">1個： ${finalOnes}個</span>
    <br>
    <span style="font-size:20px; color:#333; display:block; margin-top:5px;">10進数ではこのように10個ずつまとめて、数を表現しています。</span>
  `;
}

// --- 共通ヘルパー関数 ---

function createDots(num) {
  const dots = [];
  for (let i = 0; i < num; i++) {
    const dot = document.createElement('div');
    dot.className = 'dot';
    dot.style.transform = 'scale(0)';
    stage.appendChild(dot);
    dots.push(dot);
  }
  return dots;
}

function placeDotsRandomly(dots) {
  const stageWidth = stage.clientWidth;
  const stageHeight = stage.clientHeight - 40;
  const zone1Start = stageWidth * 0.68;
  const zone1End = stageWidth * 0.95;

  dots.forEach(dot => {
    const randX = Math.random() * (zone1End - zone1Start) + zone1Start;
    const randY = Math.random() * (stageHeight - 60) + 30;
    dot.style.left = randX + 'px';
    dot.style.top = randY + 'px';
    dot.style.zIndex = 10; // 初期値
  });
}

function calculateLayout10() {
  const stageWidth = stage.clientWidth;
  const zone10StartX = stageWidth * 0.35;
  const zone10Width = (stageWidth * 0.33) - 10;
  const colWidth = BOX_WIDTH + 8;
  let colsPerRow = Math.floor(zone10Width / colWidth);
  if (colsPerRow < 2) colsPerRow = 2;
  return { startX: zone10StartX, colWidth, colsPerRow };
}

function getPos10(index, layout) {
  const col = index % layout.colsPerRow;
  const row = Math.floor(index / layout.colsPerRow);
  const x = layout.startX + col * layout.colWidth;
  const y = 40 + row * (BOX_HEIGHT + 15);
  return { x, y };
}

function createBox10(x, y, instant = false) {
  const box = document.createElement('div');
  box.className = 'group-box-10';
  box.style.left = x + 'px';
  box.style.top = y + 'px';
  box.style.width = BOX_WIDTH + 'px';
  box.style.height = BOX_HEIGHT + 'px';
  if (instant) {
      box.style.opacity = 1;
      box.style.transition = 'none';
      setTimeout(() => box.style.transition = '', 50);
  } else {
      requestAnimationFrame(() => { box.style.opacity = 1; });
  }
  stage.appendChild(box);
  return box;
}

function arrangeLooseDots(dots, startIndex, instant = false) {
  const stageWidth = stage.clientWidth;
  const zone1GridStart = stageWidth * 0.70;
  const startY = 40;
  
  for (let i = startIndex; i < dots.length; i++) {
    const looseIdx = i - startIndex;
    const dot = dots[i];
    const col = looseIdx % 5;
    const row = Math.floor(looseIdx / 5);
    
    const targetX = zone1GridStart + col * (DOT_SIZE + 10);
    const targetY = startY + row * (DOT_SIZE + 10);
    
    if (instant) {
        dot.style.transition = 'none';
        dot.style.left = targetX + 'px';
        dot.style.top = targetY + 'px';
        dot.style.zIndex = 10;
        setTimeout(() => dot.style.transition = '', 50);
    } else {
        dot.style.left = targetX + 'px';
        dot.style.top = targetY + 'px';
        dot.style.zIndex = 10;
    }
  }
}
</script>
</body>
</html>
